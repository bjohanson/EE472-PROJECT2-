#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "headerThingy.h"


#include "inc/hw_types.h"
#include "driverlib/debug.h"
#include "driverlib/sysctl.h"
#include "drivers/rit128x96x4.h"

//Include hardware memory map, GPIO driver, and PWM driver
#include "inc/hw_memmap.h"
#include "driverlib/gpio.h"
#include "driverlib/pwm.h"
void Delay(int* foolioJenkins);
//void printGlobalCount(unsigned int count, char* foolioTibkins);

static bool north = FALSE;
static bool east = FALSE;
static bool west = FALSE;

static bool toggleNorth = FALSE;
static bool toggleEast = FALSE;
static bool toggleWest = FALSE;

static bool gridlock = FALSE;
static bool trainPresent = FALSE;
static unsigned int trainSize = 2;
static unsigned int globalCount = 0;
static unsigned int traversalTime = 0;
static unsigned int startTime = 0;

int randomInteger(int a, int b);
int main(){
  
  //Set PWM Divide Ratio to 1
  SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

    //Set Device: PWM0 Enabled
    SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
   
    //Set GPIO Port: G Enabled
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
   
    //Tell Port G, Pin 1, to take input from PWM 0
    GPIOPinTypePWM(GPIO_PORTG_BASE, GPIO_PIN_1);
   
    //Set a 440 Hz frequency as u1Period
    unsigned int ulPeriod = SysCtlClockGet() / 100;
   
    //Configure PWM0 in up-down count mode, no sync to clock
    PWMGenConfigure(PWM0_BASE, PWM_GEN_0,
                    PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);

    //Set u1Period (440 Hz) as the period of PWM0
    PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, ulPeriod);

    //Set PWM0, output 1 to a duty cycle of 1/8
   PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, ulPeriod / 16);

    //Activate PWM0
    PWMGenEnable(PWM0_BASE, PWM_GEN_0);   
  PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  

  
  trainComData ourTrainComData;
  northTrainData ourNorthTrainData;
  westTrainData ourWestTrainData;
  eastTrainData ourEastTrainData;
  switchControlData ourSwitchControlData;
  scheduleData ourScheduleData;
  
  ourTrainComData.east = &east;
  ourTrainComData.north = &north;
  ourTrainComData.west = &west;
  ourTrainComData.trainSize = &trainSize;
  ourTrainComData.trainPresent = &trainPresent;
  ourTrainComData.gridlock = &gridlock;
 
  
  ourNorthTrainData.globalCount = &globalCount;
  ourNorthTrainData.north = &north;
 //ourNorthTrainData.trainSize = &trainSize;
 ourNorthTrainData.traversalTime = &traversalTime;
 ourNorthTrainData.toggleNorth = &toggleNorth;
  
 ourScheduleData.globalCount = &globalCount;
  
 ourWestTrainData.globalCount = &globalCount;

 //ourWestTrainData.trainSize = &trainSize;
  ourWestTrainData.west = &west;
  ourWestTrainData.traversalTime = &traversalTime;
  ourWestTrainData.toggleWest = &toggleWest;
  
 ourEastTrainData.globalCount = &globalCount;

 //ourEastTrainData.trainSize = &trainSize;
 ourEastTrainData.east = &east;
 ourEastTrainData.traversalTime = &traversalTime;
 ourEastTrainData.toggleEast = &toggleEast;
 
 ourSwitchControlData.east = &east;
 ourSwitchControlData.globalCount = &globalCount;
 ourSwitchControlData.gridlock = &gridlock;
 ourSwitchControlData.north = &north;
 ourSwitchControlData.startTime = &startTime;
 ourSwitchControlData.trainPresent = &trainPresent;
 ourSwitchControlData.trainSize = &trainSize;
 ourSwitchControlData.traversalTime = &traversalTime;
 ourSwitchControlData.west = &west;

  TCB tomQueue[MAX_QUEUE_LENGTH];
  
  tomQueue[0].justTrainTaskThings = TrainCom;
  tomQueue[0].trainTaskPtr = (void*)&ourTrainComData;
  tomQueue[1].justTrainTaskThings = SwitchControl;
  tomQueue[1].trainTaskPtr = (void*)&ourSwitchControlData;
  tomQueue[2].justTrainTaskThings = NorthTrain;
  tomQueue[2].trainTaskPtr = (void*)&ourNorthTrainData;
  tomQueue[3].justTrainTaskThings = WestTrain;
  tomQueue[3].trainTaskPtr = (void*)&ourWestTrainData;
  tomQueue[4].justTrainTaskThings = EastTrain;
  tomQueue[4].trainTaskPtr = (void*)&ourEastTrainData;
  tomQueue[5].justTrainTaskThings = Schedule;
  tomQueue[5].trainTaskPtr = (void*)&ourScheduleData;
  
  
  RIT128x96x4Init(1000000); 
  
  //it breaks HERE? WHAT? NOTE TO SELF: WHAAT?
  static char flairTitle1[] = "Applehansontaft \0";
  static char flairTitle2[] = "Discount Freight \0";
  RIT128x96x4StringDraw(flairTitle1, 10, 10, 15);
  RIT128x96x4StringDraw(flairTitle2, 10, 20, 15);
  
  while(1){
    for(int i = 0; i < MAX_QUEUE_LENGTH; i++){
     tomQueue[i].justTrainTaskThings(tomQueue[i].trainTaskPtr);
    }

  }
  
}

void TrainCom(void* data){
  int direction;
  trainComData* ptr = (trainComData*)data;
  
  //Preparing a trainSize in preparation for switchControl
  //(when switchControl decides there is a train, it will use this size)
  if ((*ptr->trainPresent == FALSE)&&(*ptr->gridlock == FALSE)){
     *ptr->trainSize = randomInteger(2, 9);
     //*ptr->trainSize = 2;
  
     char numCars[] = {(char) 48 + *ptr->trainSize,'\0'};
     RIT128x96x4StringDraw("Cars: \0", 10, 50, 15);
     RIT128x96x4StringDraw(numCars, 50, 50, 15);
  }
  
  
  if ((*ptr->trainPresent == TRUE)&&(*ptr->east==FALSE)&&(*ptr->west==FALSE)&&(*ptr->north==FALSE)){
  direction = randomInteger(0, 2);
  //direction = 0;
  if(direction == 1) {
    *ptr->east = TRUE;
    *ptr->north = FALSE;    
    *ptr->west = FALSE;
  }
  else if(direction == 2) {
    *ptr->east = FALSE;
    *ptr->north = TRUE;    
    *ptr->west = FALSE;
  }
  else {
    *ptr->east = FALSE;
    *ptr->north = FALSE;    
    *ptr->west = TRUE;
  }
  
  }
   return;
}

void SwitchControl(void* data){
  switchControlData* ptr = (switchControlData*)data;
  static int rand = 0;
 // static char text[2], GL[2], TP[2];
  //static int time = 0;
  static char brando9k[] = "GRIDLOCK! \0";
  static int brightness = 0;
  //CASE 1
  //gridlock is false, trainPresent is false
  if((*ptr->gridlock==FALSE)&&(*ptr->trainPresent==FALSE)) {
    //startTime is logged as whatever current globalCount value is
    *ptr->startTime = *ptr->globalCount;
    //generate a random number between -2 and 2
    rand = randomInteger(-2, 2);
    
    //rand = 2;
    
    //if random number is less than 0, we have GRIDLOCK!
    if(rand < 0) {
      //*ptr->startTime = *ptr->globalCount;
      *ptr->gridlock = TRUE;
      //transform into positive number
      //time = -35 * rand;    
      //turn on gridlock OLED indicator
      *ptr->traversalTime = *ptr->globalCount + (-70*rand);
      brightness = 15;
      RIT128x96x4StringDraw(brando9k, 10, 40, brightness);
    }
    //if random number is greater than 0, we have a train passing through!
    else {
      *ptr->trainPresent = TRUE;
      *ptr->traversalTime = 35*(*ptr->trainSize) + *ptr->globalCount;
    }
  }
  //CASE 2
  //gridlock is true
  if(*ptr->gridlock) {
    //if globalCount exceeds gridlock timer, end gridlock
    if(*ptr->globalCount >= *ptr->traversalTime) {
      *ptr->gridlock = FALSE;
      //turn OFF gridlock indicator
      brightness = 0;
      RIT128x96x4StringDraw(brando9k, 10, 40, brightness);
    }    
  }
  
  //CASE 3
  //train is present
  if(*ptr->trainPresent) {
    if(*ptr->globalCount >= *ptr->traversalTime) {
      //*ptr->trainSize = 0;
      *ptr->trainPresent = FALSE;
      *ptr->north = FALSE;
      *ptr->east = FALSE;
      *ptr->west = FALSE;
    }
  }
  
 /* text[0] = (char)(rand + 50);
  text[1] = '\0';
  
  GL[0] = (char)(*ptr->gridlock + 48);
  GL[1] = '\0';
  
  TP[0] = (char)(*ptr->trainPresent + 48);
  TP[1] = '\0';
  
  RIT128x96x4StringDraw(text, 0, 0, 15);
  RIT128x96x4StringDraw(GL, 0, 20, 15);
  RIT128x96x4StringDraw(TP, 0, 40, 15);
  */
  return;
}

void NorthTrain(void* data){
  
  static unsigned int noiseCount = 0;
  static unsigned int northFlashCount = 0;

  static char northDisplay[] = "NorthTrain \0";
  static int brightness = 15;
  
  northTrainData* ptr = (northTrainData*) data;
   
  
  if (*ptr->north){
  //okay, start noise
  if ((*ptr->toggleNorth == FALSE)&&(*ptr->north == TRUE)){
    //localNorth = TRUE;
    *ptr->toggleNorth = TRUE;
    //localNorthCount = 35*(*ptr->trainSize) + *ptr->globalCount;
    //localNorthCount = *ptr->traversalTime;
    //*ptr->trainPresent = TRUE;
    
    noiseCount = 60 + (*ptr->globalCount);
    northFlashCount = 18 + (*ptr->globalCount);
    brightness = 15;
    
   
    //RIT128x96x4StringDraw(northDisplay, 30, 24, brightness);
  }
 
  
    if( *ptr->toggleNorth == TRUE) {
  //FLASH EVENTS
  
 
   //FLASH OFF
   if (*ptr->globalCount >= (northFlashCount - 9)){
    brightness = 15;
   RIT128x96x4StringDraw(northDisplay, 10, 40, brightness);    
   }
   
   //FLASH ON
 if (*ptr->globalCount >= northFlashCount){
   brightness = 0;
  RIT128x96x4StringDraw(northDisplay, 10, 40, brightness);
   //but wait! we may not be out of traversal time1     
 }
   //FLASH...FOREVER
 if (*ptr->globalCount >= northFlashCount){
     northFlashCount = (*ptr->globalCount + 18);
   } 
  
   //SOUND EVENTS
     
  //first blast: lasts 2 seconds
     if(*ptr->globalCount==(noiseCount - 60)) {
  PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
   }
 
  //off time between first and second blast
   if(*ptr->globalCount==(noiseCount - 48)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start second blast
   if(*ptr->globalCount==(noiseCount - 42)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait two seconds, stop second blast
   if(*ptr->globalCount==(noiseCount - 30)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start first short blast
   if(*ptr->globalCount==(noiseCount - 24)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait one second, then stop first short blast
   if(*ptr->globalCount==(noiseCount - 18)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start second short blast
   if(*ptr->globalCount==(noiseCount - 12)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait one second, end all blasts, set bigglesOn to FALSE
   if(*ptr->globalCount==(noiseCount - 6)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
   }
    
   /*if((noiseCount == *ptr->globalCount)&&(localNorth==TRUE)) {
    noiseCount = (*ptr->globalCount+60);
    }*/
  
   
    
  
    }
  }
  //placeholder: need code to STOP SOME SHIT
  if (*ptr->globalCount >= *ptr->traversalTime){
     PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
    // *ptr->trainPresent = FALSE;
     noiseCount = 0;
     northFlashCount = 0;
     //localNorthCount = 0;
     brightness = 15;
     //localNorth = FALSE; //MAAAAAAN
     *ptr->toggleNorth = FALSE;
    RIT128x96x4StringDraw(northDisplay, 10, 40, 0);
   }
 return;
}

void WestTrain(void* data){
 
  static unsigned int westNoiseCount = 0;
  static unsigned int westFlashCount = 0;
  //static bool localWest = FALSE;
  static char westDisplay[] = "WestTrain \0";
  static int brightness = 15;
  
  westTrainData* ptr = (westTrainData*) data;
   
  
   //placeholder: need code to STOP SOME SHIT
   
  if (*ptr->west){
  //okay, start noise
  if ((*ptr->toggleWest==FALSE)&&(*ptr->west == TRUE)){
    //localWest = TRUE;
    *ptr->toggleWest = TRUE;
    //localWestCount =  (*ptr->trainSize)*35 + (*ptr->globalCount);
    //localWestCount = *ptr->traversalTime;
    //*ptr->trainPresent = TRUE;
    westNoiseCount = 42 + (*ptr->globalCount);
    westFlashCount = 12 + (*ptr->globalCount);
    brightness = 15;
  }
 
  //FLASH EVENTS
  
  if(*ptr->toggleWest == TRUE) {
   //FLASH OFF
   if (*ptr->globalCount >= (westFlashCount - 6)){
    brightness = 15;
    RIT128x96x4StringDraw(westDisplay, 10, 40, brightness);    
   }
   
   //FLASH ON
 if (*ptr->globalCount >= westFlashCount){
   brightness = 0;
   RIT128x96x4StringDraw(westDisplay, 10, 40, brightness);
   //but wait! we may not be out of traversal time   
 }
   //FLASH...FOREVER
 if (*ptr->globalCount >= westFlashCount){
     westFlashCount = (*ptr->globalCount + 12);
   } 
  
   //SOUND EVENTS
   

  
     
  //first blast: lasts 2 seconds
     if(*ptr->globalCount==(westNoiseCount - 42)) {
  PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
   }
 
  //off time between first and second blast
   if(*ptr->globalCount==(westNoiseCount - 30)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start second blast
   if(*ptr->globalCount==(westNoiseCount - 24)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait two seconds, stop second blast
   if(*ptr->globalCount==(westNoiseCount - 18)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start first short blast
   if(*ptr->globalCount==(westNoiseCount - 12)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait one second, then stop first short blast
   if(*ptr->globalCount==(westNoiseCount - 6)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  
    
   /*if((westNoiseCount == *ptr->globalCount)&&(localWest==TRUE)) {
    westNoiseCount = (*ptr->globalCount+42);
    }*/
  
   }
  
  }
  if (*ptr->globalCount >= *ptr->traversalTime){
     PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
     //*ptr->trainPresent = FALSE;
     westNoiseCount = 0;
     westFlashCount = 0;
     //localWestCount = 0;
     brightness = 15;
     //localWest = FALSE; //MAAAAAAN
     *ptr->toggleWest = FALSE;
     RIT128x96x4StringDraw(westDisplay, 10, 40, 0);
   }
  return;
}

void EastTrain(void* data){
  
  static unsigned int eastNoiseCount = 0;
  static unsigned int eastFlashCount = 0;
  //static bool localEast = FALSE;
  static char eastDisplay[] = "EastTrain \0";
  static int brightness = 15;
  
  eastTrainData* ptr = (eastTrainData*) data;
  
  // RIT128x96x4StringDraw(eastDisplay, 50, 24, brightness);
  //okay, start noise
  if (*ptr->east){
  if ((*ptr->toggleEast==FALSE)&&(*ptr->east)){
    //localEast = TRUE;
    *ptr->toggleEast = TRUE;
    //localEastCount =  (*ptr->trainSize)*35 + (*ptr->globalCount);
    //localEastCount =  *ptr->traversalTime;
    //*ptr->trainPresent = TRUE;
    eastNoiseCount = 78 + (*ptr->globalCount);
    eastFlashCount = 24 + (*ptr->globalCount);
    brightness = 15;
    //PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }

  //*****FLASH EVENTS*****  
  
    if(*ptr->toggleEast == TRUE) {
   //FLASH OFF
   if (*ptr->globalCount >= (eastFlashCount - 12)){
    brightness = 15;
    RIT128x96x4StringDraw(eastDisplay, 10, 40, brightness);    
   }
   
   //FLASH ON
 if (*ptr->globalCount >= eastFlashCount){
   brightness = 0;
   RIT128x96x4StringDraw(eastDisplay, 10, 40, brightness);
   //but wait! we may not be out of traversal time   
 }
   //FLASH...FOREVER
 if (*ptr->globalCount >= eastFlashCount){
     eastFlashCount = (*ptr->globalCount + 24);
   } 
  
   //*****SOUND EVENTS*****
  
  //first blast: lasts 2 seconds
     if(*ptr->globalCount==(eastNoiseCount - 78)) {
  PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
   }
  //off time between first and second blast
   if(*ptr->globalCount==(eastNoiseCount - 66)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start second blast
   if(*ptr->globalCount==(eastNoiseCount - 60)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait two seconds, stop second blast
   if(*ptr->globalCount==(eastNoiseCount - 48)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start first short blast
   if(*ptr->globalCount==(eastNoiseCount - 42)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait one second, then stop first short blast
   if(*ptr->globalCount==(eastNoiseCount - 30)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
   }
    //first blast: lasts 2 seconds
     if(*ptr->globalCount==(eastNoiseCount - 24)) {
  PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
   }
  //off time between first and second blast
   if(*ptr->globalCount==(eastNoiseCount - 18)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  //wait one second, then start second blast
   if(*ptr->globalCount==(eastNoiseCount - 12)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, TRUE);
  }
  //wait two seconds, stop second blast
   if(*ptr->globalCount==(eastNoiseCount - 6)) {
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
  }
  
  }
   /*if((eastNoiseCount == *ptr->globalCount)&&(localEast==TRUE)) {
    eastNoiseCount = (*ptr->globalCount+78);
    }*/
  
   
  
  }
  if (*ptr->globalCount >= *ptr->traversalTime){
     PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, FALSE);
     //*ptr->trainPresent = FALSE;
     eastNoiseCount = 0;
     eastFlashCount = 0;
     //localEastCount = 0;
     brightness = 15;
     //localEast = FALSE; //MAAAAAAN
     *ptr->toggleEast = FALSE;
     RIT128x96x4StringDraw(eastDisplay, 10, 40, 0);
  }
    return;
}

void Schedule(void* data){
  static unsigned int justinCrazy;
  static char globalCountArray[10];
  for (int tibo = 0; tibo < 10; tibo++){
    globalCountArray[tibo] = ' ';
  }
  
  
  scheduleData* tomPtr = (scheduleData*) data; 
  int delay1 = 250000;
  Delay(&delay1);
  //static unsigned int justinCrazy = 0;
  justinCrazy = *tomPtr->globalCount;
  justinCrazy++;
  *tomPtr->globalCount = justinCrazy;
  char scheduleTitle[] = "TOM TIME: \0";
  RIT128x96x4StringDraw(scheduleTitle, 0, 75, 15);
 
   int i = 9; 
  
  while(justinCrazy > 0) {
    globalCountArray[i] = (justinCrazy%10) + 48;
    justinCrazy = justinCrazy/10;
    i--;     
  }  
  RIT128x96x4StringDraw(globalCountArray, 50, 75, 15);
  //free(i);
  return;
}
void Delay(int *waffle)
{
 
  for(int d=*waffle; d>0; d--);
  return;
}
//CODE STOLEN FROM:
int seed = 1;
int randomInteger(int low, int high)
{
        
	double randNum = 0.0;
 	int multiplier = 2743;
	int addOn = 5923;
	double max = INT_MAX + 1.0;

	int retVal = 0;

	if (low > high)
		retVal = randomInteger(high, low);
	else
	{
   		seed = seed*multiplier + addOn;
   		randNum = seed;

		if (randNum <0)
		{
			randNum = randNum + max;
		}

		randNum = randNum/max;

		retVal =  ((int)((high-low+1)*randNum))+low;
	}
	
	return retVal;
}
